From 07455b26521352a455cc5ed5e70c3e4cd77ea04a Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Tue, 19 Sep 2023 13:50:21 +0800
Subject: [PATCH] vhost: restart device when memory region changed

There are cases for users to add a new memory region during
runtime, in earlier SPDK versions before 23.01, SPDK supported
this feature via restart the device for any new SET_MEM_TABLE
messages.  In the commit 23baa676 we removed this support to
start device only once, since users are still requiring this
feature, so adding it back.

Fix issue #3132.

Change-Id: I6dcb427eb56b778d9804f89c5998b2179ea3a916
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
---

diff --git a/lib/vhost/rte_vhost_user.c b/lib/vhost/rte_vhost_user.c
index 232cb3e..98b9ed5 100644
--- a/lib/vhost/rte_vhost_user.c
+++ b/lib/vhost/rte_vhost_user.c
@@ -1470,6 +1470,19 @@
 		}
 		pthread_mutex_unlock(&user_dev->lock);
 		break;
+	case VHOST_USER_SET_MEM_TABLE:
+		pthread_mutex_lock(&user_dev->lock);
+		if (vsession->started) {
+			vsession->original_max_queues = vsession->max_queues;
+			pthread_mutex_unlock(&user_dev->lock);
+			/* `stop_device` is running in synchronous, it
+			 * will hold this lock again before exiting.
+			 */
+			g_spdk_vhost_ops.destroy_device(vid);
+			vsession->needs_restart = true;
+		}
+		pthread_mutex_unlock(&user_dev->lock);
+		break;
 	case VHOST_USER_GET_CONFIG: {
 		int rc = 0;
 
@@ -1522,10 +1535,6 @@
 	}
 	user_dev = to_user_dev(vsession->vdev);
 
-	if (msg->request == VHOST_USER_SET_MEM_TABLE) {
-		vhost_register_memtable_if_required(vsession, vid);
-	}
-
 	switch (msg->request) {
 	case VHOST_USER_SET_FEATURES:
 		rc = vhost_get_negotiated_features(vid, &vsession->negotiated_features);
@@ -1559,6 +1568,21 @@
 		}
 		pthread_mutex_unlock(&user_dev->lock);
 		break;
+	case VHOST_USER_SET_MEM_TABLE:
+		vhost_register_memtable_if_required(vsession, vid);
+		pthread_mutex_lock(&user_dev->lock);
+		if (vsession->needs_restart) {
+			vsession->needs_restart = false;
+			pthread_mutex_unlock(&user_dev->lock);
+			for (qid = 0; qid < vsession->original_max_queues; qid++) {
+				enable_device_vq(vsession, qid);
+			}
+			vsession->original_max_queues = 0;
+			g_spdk_vhost_ops.new_device(vid);
+			break;
+		}
+		pthread_mutex_unlock(&user_dev->lock);
+		break;
 	default:
 		break;
 	}
diff --git a/lib/vhost/vhost_internal.h b/lib/vhost/vhost_internal.h
index 38229ff..a9539a3 100644
--- a/lib/vhost/vhost_internal.h
+++ b/lib/vhost/vhost_internal.h
@@ -116,12 +116,15 @@
 	bool started;
 	bool starting;
 	bool interrupt_mode;
+	bool needs_restart;
 
 	struct rte_vhost_memory *mem;
 
 	int task_cnt;
 
 	uint16_t max_queues;
+	/* Maximum number of queues before restart, used with 'needs_restart' flag */
+	uint16_t original_max_queues;
 
 	uint64_t negotiated_features;
 
